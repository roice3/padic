<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  width: 900px;
  height: 900px;
  position: relative;
}

form {
  position: absolute;
  top: 1em;
  left: 1em;
}

path {
  fill-rule: evenodd;
  stroke: #333;
  stroke-width: 4px;
}

.sector0 path {
  fill: #FF0000;
}

.sector1 path {
  fill: #FFFFFF;
}

.sector2 path {
  fill: #0000FF;
}

</style>
<form>
</form>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

// Each circle in this animation will have an associated base-p number.  For the 2-adic case,
// each circle will be assigned a binary number.  The number is the encoding of the location of the circle
// in the hierarchy.  0 will mean "left side" and 1 will mean "right side"  The root level-0 circle string 
// will be "", and levels will be encoded right-to-left.
// E.g. the string "110" is a level-3 circle to the left on level 1 and to the right on levels 2 and 3.
//
// Javascript does not support binary, trinary, ... numeric literals.
// http://stackoverflow.com/questions/2803145/is-there-0b-or-something-similar-to-represent-a-binary-number-in-javascript
// So we are going to have to use the string form of these to track the data of our circles.
// This is perhaps better anyway as we want to distinguish between "10" (the left circle at the second level) and "010"
// (the right circle at the third level)
//
// TODO:
// * Save output as image:  http://d3export.housegordon.org/
// * Make work for addition by larger numbers.
// * Make work for 3-adic, etc.
//

var m_width = 900,
    m_height = 900
    m_radius = m_width * 0.9,
	m_p = 2,	// p-adic
	m_levels = 6,
	m_angleParam = 20;	// An angle parameter for the 2-adic case.

var m_speed = 8,
    m_start = Date.now();

var svg = d3.select("body").append("svg")
    .attr("width", m_width)
    .attr("height", m_height)
  .append("g")
    .attr("transform", "translate(" + m_width / 2 + "," + m_height / 2 + ")scale(.5)")
  .append("g");

var frame = svg.append("g");

// Add the root circle, then recursively add all our other circles.
// Doing this recursively will more easily allow setting the p-adic encoding strings.
// Also, it will allow us to have the proper group hierarchy for nested rotations.
var rootGroup = frame.append("g");
var rootString = "";
var rootLovel = 0;
var circleGroup = addCircle( rootString, rootLovel, rootGroup, false );
addCirclesRecursive( rootLovel, circleGroup, rootString );

function addCirclesRecursive( level, parentGroup, parentCode )
{
	if( ++level > m_levels )
		return;
	
	for( var i=0; i<m_p; i++ )
	{
		left = i == 0;
		code = i.toString() + parentCode;
		var circleGroup = addCircle( code, level, parentGroup, left );		
		addCirclesRecursive( level, circleGroup, code );
	}
}

function addCircle( code, level, group, left )
{
	// We want to apply the angle param to any circle on the right.
	var angleOffset = 0;
	if( m_p == 2 && level > 0 )
	{
		//var angleOffset = code.charAt(0) == "1" ? -m_angleParam : 0;
		
		// Edmund's suggestion.
		angleOffset = level % 2 == 1 ? -m_angleParam : m_angleParam;
	}
	
	// r and offset calc only works for 2-adic now.
	var r = m_radius / Math.pow( m_p, level ),
		offset = level == 0 ? 0 : left ? -r : r;
	var circleGroup = group.append("g")
		.attr("transform", "translate(" + offset + "," + 0 + ") rotate(" + angleOffset + ") ")
		.datum({});	// Not exactly sure why, but empty datum was needed here to make transforms work correctly.
		
	// Create a group to which we'll apply rotations, and assign
	// it our code.  The circleGroup created above already
	// has a transform set on it, which is the reason for the
	// extra group here.
	var circleGroupRotation = circleGroup.append("g")
		.datum({id: code});	
		
	// A group to track the state of things.	
	var state = 0;
	var stateGroup = circleGroupRotation.append("g")
		.datum({id: code, state: state});
		
	// Add in all the sectors for this circle.
	for( sector=0; sector<m_p; sector++ )
	{
		var className = "sector" + sector;
		stateGroup.append("g")
			.attr("class", className)
			.attr("transform", "rotate(" + (360/m_p)*sector + ")")
			.datum({radius: r})
		.append("path")
			.attr("d", drawSector);
	}
	
	// Note: It is important to return this group and not stateGroup so that
	//		 our state transformations do not affect all the circles below.
	return circleGroupRotation;
}

function drawSector(d)
{
	var r = Math.abs(d.radius),
		a = 2*Math.PI/m_p,
		ex = r*Math.cos(a),
		ey = r*Math.sin(a),
		path = 
		[
			"M", r, ",", 0,
			"L", 0, ",", 0,
			"L", ex, ",", ey,
			"A", r, ",", r, " 0 0,0 ", r, ",", 0,
			"Z"
		];
	return path.join("");
}

function reverseString(s) 
{
  return s.split('').reverse().join('');
}

// Are we affected by the p-adic operation?
// XXX - (support more operations here later).
// XXX - This doesn't pad or trim the resulting string.
function performAdd( code, num )
{	
	var numCodes = Math.pow( m_p, code.length );

	// Convert to base-10 
	var base10 = parseInt( code, m_p );
	
	// Perform the arithmetic
	base10 += num;
	if( base10 < 0 )
		base10 += numCodes;
	base10 %= numCodes;	// We need to mod it out.
	
	// Back to base-2.
	var basep = base10.toString( m_p );
	return basep;
}

function performAddPad( code, num )
{
	if( code == "" )
		return code;

	var length = code.length,
		result = "0000000" + performAdd( code, num ),	// XXX - fragile
		result = result.slice( -length );
		
	return result;
}

function rolledOver( code )
{
	if( code == NoParent )
		return false;

	var after = performAdd( code, 1 );
	
	// Some other interesting choices for when to rotate.
	//var spin = after.charAt(d.level) == "0";
	//var spin = d.id.length != after.length;
	// after.length == code.length + 1
	
	// We need to rotate if we rolled over.
	var rolledOver = 
		code.length == "" || -1 == after.search( "1" );	// XXX - won't work with addition by 2.
	return rolledOver;
}

// Returns -1, 0, or 1
function spinCount( code )
{
	var count = rolledOver( code ) ? 1 : 0;

	// If the parent is spinning, we need to counteract that.
	if( rolledOver( parentCode( code ) ) )
		count -= 1;
		
	return count;
}

var NoParent = "NONE";

function parentCode( code )
{
	if( code.length == 0 )
		return NoParent;

	return code.substring( 1, code.length );
}

function updateState()
{
	var calcNewState = function(d) 
	{
		// We need to update the ID of the group.
		// Where were we before?
		d.id = performAddPad( d.id, -1 );
	
		// Did our previous location spin?
		var rolled = rolledOver( d.id );
		if( rolled )
			d.state = d.state == 0 ? 1 : 0;
		
		return d;
	};

	var transform = function(d) 
	{ 
		return "rotate(" + 180*d.state + ")"; 
	};
	
	frame.selectAll("g")
		.filter( 
			function(d, i) 
			{ 
				// Grab the state groups.
				var hasId = d != null && d.id != null && d.state != null;
				return hasId;
			} )
		.datum(calcNewState)
		.attr("transform", transform);
}

d3.timer
(
	function() 
	{
		var angle = (Date.now() - m_start) * m_speed / m_radius;
		if( angle > 180 )
		{
			updateState();
			for( var i=0; i<10; i++ )
				updateState();
			angle = 0;
			m_start = Date.now();
		}			

		var transform = function(d) 
		{ 
			var count = spinCount( d.id )
			return "rotate(" + -angle*count + ")"; 
		};
		  
		frame.selectAll("g")
			.filter( 
				function(d, i) 
				{ 
					// Grab those with valid IDs which are not a stateGroup.
					var hasId = d != null && d.id != null && d.state == null;
					return hasId;
				} )	
			.attr("transform", transform);
	}
);

</script>